# -*- coding: utf-8 -*-
"""BANK RECONCILATION UI_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hqpKTJ-mPrq_Nya1WEtsd5kaca7snY9-
"""

# BANK RECONCILATION UI_AI
import pandas as pd
import io
import ipywidgets as widgets
from IPython.display import display,clear_output

# File upload widgets
ledger_upload = widgets.FileUpload(accept=".csv,.xlsx",multiple=False,description="Upload Ledger")
bank_upload = widgets.FileUpload(accept=".csv,.xlsx",multiple=False,description="Upload Bank Statement")
reconcile_button = widgets.Button(description="Reconcile")
button_style ='green'
reconcile_button.style.button_color = button_style

def on_reconcile_button_clicked(b):
    global ledger_df, bank_df # Use global variables to store the dataframes
    with output:
        clear_output() # Clear previous output

        # Load files
        ledger_df = load_file(ledger_upload)
        bank_df = load_file(bank_upload)

        # Check if files are loaded
        if ledger_df is None or bank_df is None:
            print("Please upload both Ledger and Bank Statement files.")
            return

        # Ensure Date column is in datetime format
        try:
            ledger_df['Date'] = pd.to_datetime(ledger_df['Date'])
            bank_df['Date'] = pd.to_datetime(bank_df['Date'])
        except KeyError as e:
            print(f"Error: Missing expected date column in one of the files: {e}")
            return
        except Exception as e:
            print(f"An unexpected error occurred during date conversion: {e}")
            return

        # Call the reconcile function if data is loaded and dates are formatted
        reconcile_data(ledger_df, bank_df)

# Attach the function to the button's click event
reconcile_button.on_click(on_reconcile_button_clicked)

# OUTPUT WIDGETS FOR RESULTS
output = widgets.Output()

# Display UI
ui = widgets.VBox([widgets.HBox([ledger_upload,bank_upload,]),reconcile_button,output])
display(ui)

# Global Dataframes
ledger_df = pd.DataFrame()
bank_df = pd.DataFrame()

# Function to upload file into DataFrame
def load_file(upload_widget):
  if len(upload_widget.value)==0:
    return None
  file_info = next(iter(upload_widget.value.values()))
  content = io.BytesIO(file_info['content'])
  file_name = file_info['metadata']['name']

  if file_name.endswith(".csv"):
    return pd.read_csv(content)
  elif file_name.endswith(".xlsx"):
    return pd.read_excel(content)
  else:
    return None

# Load the files
ledger_df = load_file(ledger_upload)
bank_df = load_file(bank_upload)

if ledger_df is None or bank_df is None:
  # Handle the case where files are not loaded, perhaps display a message
  # to the user or raise an error. For now, we'll just return.
  print("Please upload both Ledger and Bank Statement files.")
  # Consider returning or exiting the function here if files are not loaded
  # return

# Ensure Data column is in datetime format
try:
  ledger_df['Date']= pd.to_datetime(ledger_df['Date'])
  bank_df['Date'] = pd.to_datetime(bank_df['Date'])
except KeyError as e:
  print(f"Error: Missing expected date column in one of the files: {e}")
  # Handle the case where 'Date' column is missing, perhaps return or raise error
except Exception as e:
  print(f"An unexpected error occurred during date conversion: {e}")
  # Handle other potential errors during conversion

# Display UI
ui = widgets.VBox([widgets.HBox([ledger_upload,bank_upload,]),reconcile_button,output])
display(ui)

# Reconcilation logic
def reconcile_data(Ledger_df,Bank_df):
  with output:
    clear_output()

    # Rename columns for clarity and merging
    ledger_df_renamed = Ledger_df.copy()
    bank_df_renamed = Bank_df.copy()

    # Assuming 'Amount' and 'Description' are common columns for matching
    # You might need to adjust these column names based on the actual data
    common_cols = ['Date', 'Amount'] # Add 'Description' if available and relevant

    # Inner merge to find matched transactions
    # Using a left merge followed by filtering can handle potential duplicate matches more robustly
    matched_transactions = pd.merge(
        ledger_df_renamed,
        bank_df_renamed,
        on=common_cols,
        how='inner',
        suffixes=('_ledger', '_bank')
    )


    # Identify unmatched ledger transactions
    unmatched_ledger = pd.merge(
        ledger_df_renamed,
        matched_transactions[common_cols].drop_duplicates(),
        on=common_cols,
        how='left',
        indicator=True
    )
    unmatched_ledger = unmatched_ledger[unmatched_ledger['_merge'] == 'left_only'].drop('_merge', axis=1)


    # Identify unmatched bank transactions
    unmatched_bank = pd.merge(
        bank_df_renamed,
        matched_transactions[common_cols].drop_duplicates(),
        on=common_cols,
        how='left',
        indicator=True
    )
    unmatched_bank = unmatched_bank[unmatched_bank['_merge'] == 'left_only'].drop('_merge', axis=1)


    # Display results (optional, for debugging or user feedback)
    print("Reconciliation Complete:")
    print(f"Matched Transactions: {len(matched_transactions)}")
    print(f"Unmatched Ledger Transactions: {len(unmatched_ledger)}")
    print(f"Unmatched Bank Transactions: {len(unmatched_bank)}")

    # You can return these dataframes or make them available globally if needed
    # global matched_transactions, unmatched_ledger, unmatched_bank
    # matched_transactions = matched_transactions
    # unmatched_ledger = unmatched_ledger
    # unmatched_bank = unmatched_bank