# -*- coding: utf-8 -*-
"""Civil Engineering Project Schedule UI_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/128vClWci_f0gLk0VYl1pkgMr2v-x3erb
"""

# Civil Engineering- Project Scheduling UI_AI
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, clear_output

# Default Project Data
data = {"Task":["A-Site preparation","B-Foundation","C-Structure","D-MEP","E-Finishing","F-Handover"],
"Duration":[5,10,20,15,12,5],
"Dependencies":["","A-Site Preparation","B-Foundation","C=Structure","D- MEP","E-Finishing",]}
df = pd.DataFrame(data)

# CPM Calculation Function
def compute_cpm(df):
    G = nx.DiGraph()

    # Add Tasks
    for _, row in df.iterrows():
        task = row["Task"]
        duration = row["Duration"]
        G.add_node(task, duration=duration) # Add duration attribute here

    # Add dependencies and edges
    for _, row in df.iterrows():
        task = row["Task"]
        dependencies = row["Dependencies"]
        if dependencies: # Check if dependencies is not empty
            # Split dependencies by comma and strip whitespace
            for dep in [d.strip() for d in dependencies.split(",")]:
                # Ensure the dependency node exists before adding edge
                if dep in G.nodes:
                  G.add_edge(dep, task)
                else:
                    # Handle cases where dependency might not be a listed task
                    # For now, we'll just print a warning
                    print(f"Warning: Dependency '{dep}' for task '{task}' not found in task list.")

    return G

# CPM Calculation
G = compute_cpm(df)

# Forward Pass
ES, EF = {}, {}
for node in nx.topological_sort(G):
    if not list(G.predecessors(node)):
        ES[node] = 0
    else:
        ES[node] = max(EF[p] for p in G.predecessors(node))
    EF[node] = ES[node] + G.nodes[node]["duration"]

# Backward Pass
LF, LS = {}, {}
maxEF = max(EF.values())
for node in reversed(list(nx.topological_sort(G))):
    if not list(G.successors(node)):
        LF[node] = maxEF
    else:
        LF[node] = min(LS[s] for s in G.successors(node))
    LS[node] = LF[node] - G.nodes[node]["duration"]

# Slack and Critical Path
slack = {task: LS[task] - ES[task] for task in G.nodes}
critical_path = [task for task in G.nodes if slack[task] == 0]
result = pd.DataFrame({
    "Task": list(G.nodes),
    "Duration": [G.nodes[task]["duration"] for task in G.nodes],
    "ES": [ES[task] for task in G.nodes],
    "EF": [EF[task] for task in G.nodes],
    "LS": [LS[task] for task in G.nodes],
    "LF": [LF[task] for task in G.nodes],
    "Slack": [slack[task] for task in G.nodes],
    "Critical": ["*" if task in critical_path else "" for task in G.nodes]
})
display(result)
print("Critical Path:", " --> ".join(critical_path))

print(f"Total project duration: {maxEF} days")

import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(12, 8))

# Number of tasks
num_tasks = len(result)

# Create a list of task names for y-axis labels
task_names = result['Task'].tolist()

# Iterate through each task and plot the bars
for i, (index, row) in enumerate(result.iterrows()):
    task = row['Task']
    es = row['ES']
    ef = row['EF']
    ls = row['LS']
    lf = row['LF']
    is_critical = row['Critical'] == '*'

    # Plot Early Start to Early Finish (light color, solid)
    ax.barh(task, ef - es, left=es, height=0.4, align='center', color='lightblue', edgecolor='blue', label='Early Schedule' if i == 0 else "")

    # Plot Late Start to Late Finish (darker color, dashed edge)
    ax.barh(task, lf - ls, left=ls, height=0.8, align='center', color='gray', alpha=0.3, edgecolor='dimgray', linestyle='--', label='Late Schedule' if i == 0 else "")

    # Highlight critical path tasks
    if is_critical:
        ax.barh(task, ef - es, left=es, height=0.6, align='center', color='salmon', edgecolor='red', linewidth=1.5, label='Critical Path' if i == 0 else "")

# Set labels and title
ax.set_xlabel('Time (Days)')
ax.set_ylabel('Task')
ax.set_title('Project Gantt Chart')
ax.set_yticks(range(num_tasks))
ax.set_yticklabels(task_names)
ax.invert_yaxis()  # Tasks from top to bottom
ax.legend(handles=[plt.Rectangle((0,0),1,1, color='lightblue', edgecolor='blue'),
                   plt.Rectangle((0,0),1,1, color='gray', alpha=0.3, edgecolor='dimgray', linestyle='--'),
                   plt.Rectangle((0,0),1,1, color='salmon', edgecolor='red', linewidth=1.5)],
          labels=['Early Schedule', 'Late Schedule', 'Critical Path'])
ax.grid(axis='x', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

# Slack and Critical Path
slack = {task: LS[task] - ES[task] for task in G.nodes}
critical_path = [task for task in G.nodes if slack[task] == 0]
result = pd.DataFrame({
    "Task": list(G.nodes),
    "Duration": [G.nodes[task]["duration"] for task in G.nodes],
    "ES": [ES[task] for task in G.nodes],
    "EF": [EF[task] for task in G.nodes],
    "LS": [LS[task] for task in G.nodes],
    "LF": [LF[task] for task in G.nodes],
    "Slack": [slack[task] for task in G.nodes],
    "Critical": ["*" if task in critical_path else "" for task in G.nodes]
})
# The original code had a return statement here, but this cell appears to be for calculation and display,
# not a function definition. I will remove the return statement.
# return result, G,critical_path

# UI Update Function
def update_table(change=None):
    clear_output(wait=True)
    # Read values from widgets
    tasks = [t.strip() for t in task_box.value.split(",") if t.strip()]
    durations = [int(d.strip()) for d in duration_box.value.split(",") if d.strip()]
    dependencies = [d.strip() for d in dependencies_box.value.split(",") if d.strip()]

    # Ensure all lists have the same length (handle missing dependencies)
    while len(dependencies) < len(tasks):
        dependencies.append("")

    df = pd.DataFrame({
        "Task": tasks,
        "Duration": durations,
        "Dependencies": dependencies
    })

    G = compute_cpm(df)
    result, G, critical_path = calculate_cpm(df, G) # Pass G to calculate_cpm
    print("Critical Path:", " --> ".join(critical_path))
    display(result)

# Need a function to combine the forward/backward pass and slack/critical path calculations
def calculate_cpm(df, G):
    # Forward Pass
    ES, EF = {}, {}
    for node in nx.topological_sort(G):
        if not list(G.predecessors(node)):
            ES[node] = 0
        else:
            ES[node] = max(EF[p] for p in G.predecessors(node))
        EF[node] = ES[node] + G.nodes[node]["duration"]

    # Backward Pass
    LF, LS = {}, {}
    maxEF = max(EF.values())
    for node in reversed(list(nx.topological_sort(G))):
        if not list(G.successors(node)):
            LF[node] = maxEF
        else:
            LF[node] = min(LS[s] for s in G.successors(node))
        LS[node] = LF[node] - G.nodes[node]["duration"]

    # Slack and Critical Path
    slack = {task: LS[task] - ES[task] for task in G.nodes}
    critical_path = [task for task in G.nodes if slack[task] == 0]
    result = pd.DataFrame({
        "Task": list(G.nodes),
        "Duration": [G.nodes[task]["duration"] for task in G.nodes],
        "ES": [ES[task] for task in G.nodes],
        "EF": [EF[task] for task in G.nodes],
        "LS": [LS[task] for task in G.nodes],
        "LF": [LF[task] for task in G.nodes],
        "Slack": [slack[task] for task in G.nodes],
        "Critical": ["*" if task in critical_path else "" for task in G.nodes]
    })
    return result, G, critical_path

# Draw Graph
# Calculate CPM with default data to define G and critical_path in the global scope
result, G, critical_path = calculate_cpm(df, compute_cpm(df))

plt.figure(figsize=(10,10))
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels=True,
        node_size=2500, node_color="lightblue", font_size=8)
# Draw critical path nodes separately to highlight them
nx.draw_networkx_nodes(G, pos, nodelist=critical_path, node_color="red", node_size=2500)
plt.title("CPM NETWORK (Critical Path in Red)")
plt.show()